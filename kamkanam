#!/usr/bin/env python3
import argparse
import json
import os
import re
import subprocess
import sys
import textwrap
import urllib.error
import urllib.request
from collections import Counter


AI_STYLE_PATTERNS = [
    r"\b(this|the)\s+(function|method|class|module|script|file|component)\b",
    r"\b(args|arguments|parameters|returns?|raises?)\b",
    r"\b(example|usage|note|important|ensure|make sure)\b",
    r"\bTODO\b|\bFIXME\b|\bTBD\b|\bplaceholder\b|\bstub\b",
]

AI_DISCLAIMER_PATTERNS = [
    r"\bas an ai\b",
    r"\blanguage model\b",
    r"\bai[- ]?generated\b",
    r"\bgenerated by ai\b",
]

COMMENT_PREFIXES = ("#", "//", "/*", "*", "*/", ";")
DOCSTRING_TOKENS = ('"""', "'''")
REPEATED_LINE_MIN_LEN = 24
REPEATED_LINE_MIN_COUNT = 4


def run_git(args, cwd):
    result = subprocess.run(
        ["git"] + args,
        cwd=cwd,
        text=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        check=False,
    )
    if result.returncode != 0:
        raise RuntimeError(result.stderr.strip() or "git command failed")
    return result.stdout


def parse_bool(value):
    return str(value).lower() in ("1", "true", "yes", "on")


def debug_enabled():
    return parse_bool(os.getenv("KAMKANAM_DEBUG", "0"))


def debug_log(message):
    if debug_enabled():
        print(f"kamkanam: {message}", file=sys.stderr)


def gemini_model():
    return os.getenv("KAMKANAM_GEMINI_MODEL", "gemini-2.5-flash")


def tui_enabled():
    return parse_bool(os.getenv("KAMKANAM_TUI", "1"))


def prompt_tui(message):
    if not tui_enabled():
        debug_log("tui disabled; auto-accepting")
        return True
    try:
        tty = open("/dev/tty", "r+")
    except OSError:
        debug_log("no tty available; auto-accepting")
        return True
    with tty:
        tty.write("\nkamkanam commit message:\n")
        tty.write("-" * 72 + "\n")
        tty.write(message.rstrip() + "\n")
        tty.write("-" * 72 + "\n")
        tty.write("Press Enter to accept, or type 'q' to abort: ")
        tty.flush()
        response = tty.readline()
    if response is None:
        return True
    response = response.strip().lower()
    return response not in ("q", "quit", "n", "no")


def repo_root():
    try:
        root = run_git(["rev-parse", "--show-toplevel"], cwd=os.getcwd()).strip()
    except RuntimeError as exc:
        raise RuntimeError("not a git repository") from exc
    if not root:
        raise RuntimeError("not a git repository")
    return root


def get_staged_diff(cwd):
    return run_git(["diff", "--cached", "--unified=0", "--no-color"], cwd=cwd)


def get_stat(cwd):
    return run_git(["diff", "--cached", "--stat", "--no-color"], cwd=cwd)


def get_name_status(cwd):
    output = run_git(["diff", "--cached", "--name-status", "-z"], cwd=cwd)
    parts = output.split("\0")
    items = []
    i = 0
    while i < len(parts):
        entry = parts[i]
        if not entry:
            i += 1
            continue
        if "\t" in entry:
            status, path = entry.split("\t", 1)
        else:
            status, path = entry, ""
        code = status[:1]
        if code in ("R", "C"):
            old_path = path
            new_path = ""
            if i + 1 < len(parts):
                new_path = parts[i + 1]
                i += 1
            items.append((code, old_path, new_path))
        else:
            items.append((code, path, None))
        i += 1
    return items


def compile_patterns(patterns):
    return [re.compile(p, re.IGNORECASE) for p in patterns]


AI_STYLE_REGEX = compile_patterns(AI_STYLE_PATTERNS)
AI_DISCLAIMER_REGEX = compile_patterns(AI_DISCLAIMER_PATTERNS)
ALLOWED_TYPES = {"chore", "feature", "refactor", "bug", "hotfix"}
TYPE_ALIASES = {
    "fix": "bug",
    "bugfix": "bug",
    "feat": "feature",
    "feature": "feature",
    "refactor": "refactor",
    "hotfix": "hotfix",
    "chore": "chore",
}

def is_comment_line(line):
    stripped = line.lstrip()
    if not stripped:
        return False
    if stripped.startswith(COMMENT_PREFIXES):
        return True
    if stripped.startswith(DOCSTRING_TOKENS):
        return True
    return False


def normalize_line(line):
    line = line.strip()
    if not line:
        return ""
    return re.sub(r"\s+", " ", line)


def repeated_lines_set(lines):
    normalized = []
    for line in lines:
        norm = normalize_line(line)
        if len(norm) < REPEATED_LINE_MIN_LEN:
            continue
        normalized.append(norm)
    counts = Counter(normalized)
    return {line for line, count in counts.items() if count >= REPEATED_LINE_MIN_COUNT}


def is_ai_line(line, repeated_lines):
    stripped = line.strip()
    if not stripped:
        return False
    if normalize_line(stripped) in repeated_lines:
        return True
    if any(regex.search(stripped) for regex in AI_DISCLAIMER_REGEX):
        return True
    if is_comment_line(stripped) and any(regex.search(stripped) for regex in AI_STYLE_REGEX):
        return True
    return False


def compute_ai_percent(diff_text):
    added_lines = []
    for line in diff_text.splitlines():
        if line.startswith("+") and not line.startswith("+++"):
            content = line[1:]
            if content.strip():
                added_lines.append(content)
    total_added = len(added_lines)
    if total_added == 0:
        return 0
    repeated = repeated_lines_set(added_lines)
    ai_added = 0
    for line in added_lines:
        if is_ai_line(line, repeated):
            ai_added += 1
    return int(round(100 * ai_added / total_added))


def fallback_message(name_status):
    if not name_status:
        return "chore: empty commit"
    if len(name_status) == 1:
        code, path, new_path = name_status[0]
        if code == "A":
            subject = f"add {path}"
        elif code == "D":
            subject = f"remove {path}"
        elif code == "R" and new_path:
            subject = f"rename {path} to {new_path}"
        elif code == "C" and new_path:
            subject = f"copy {path} to {new_path}"
        else:
            subject = f"update {path}"
        return shorten_subject(subject)
    return f"update {len(name_status)} files"


def shorten_subject(subject, max_len=72):
    subject = subject.strip()
    if len(subject) <= max_len:
        return subject
    return subject[: max_len - 3].rstrip() + "..."


def build_prompt(diff_text, stat_text, name_status, ai_percent, existing_message, ai_percent_override):
    max_chars = int(os.getenv("KAMKANAM_MAX_DIFF_CHARS", "12000"))
    diff_excerpt = diff_text[:max_chars]
    if len(diff_text) > max_chars:
        diff_excerpt += "\n...[diff truncated]"
    files_list = []
    for code, path, new_path in name_status:
        if code == "R" and new_path:
            files_list.append(f"R {path} -> {new_path}")
        elif code == "C" and new_path:
            files_list.append(f"C {path} -> {new_path}")
        else:
            files_list.append(f"{code} {path}")
    files_block = "\n".join(files_list) if files_list else "(none)"
    existing_message = existing_message or ""
    existing_block = existing_message.strip() if existing_message.strip() else "(none)"
    if ai_percent_override is not None:
        ai_hint = f"AI usage override: {ai_percent_override}% (use this exact value)."
    else:
        ai_hint = (
            "Estimate AI usage from code patterns only (ignore @generated annotations "
            f"and file paths). Heuristic reference: {ai_percent}%."
        )
    prompt = textwrap.dedent(
        f"""\
        Given the git diff and commit message, analyze exactly what changed, classify
        the commit type (chore/feature/refactor/bug/hotfix), verify whether the commit
        message accurately reflects the code changes (rewrite if needed), detect
        AI-generated code patterns (boilerplate symmetry, unnatural consistency,
        verbose comments, prompt-like naming, over-generalization), estimate AI usage
        as a percentage (0-100), and output exactly one line in this format:
        <type> : <commit message> : ai-usage <percentage>

        Requirements:
        - Output exactly one line, no markdown fences, no quotes.
        - Commit message must be imperative and <=72 characters.
        - Percentage must be an integer 0-100 with no percent sign.
        - Do not include the type label inside the commit message.
        - Do not include extra commentary.

        Existing commit message:
        {existing_block}

        Diff stat:
        {stat_text.strip() or "(empty)"}

        {ai_hint}

        Changed files:
        {files_block}

        Staged diff (truncated if needed):
        {diff_excerpt.strip() or "(empty)"}
        """
    )
    return prompt


def call_gemini(prompt):
    api_key = os.getenv("KAMKANAM_GEMINI_API_KEY") or os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise RuntimeError("missing Gemini API key")
    model = gemini_model()
    debug_log(f"using Gemini model: {model}")
    url = (
        "https://generativelanguage.googleapis.com/v1beta/models/"
        f"{model}:generateContent?key={api_key}"
    )
    payload = {
        "contents": [{"role": "user", "parts": [{"text": prompt}]}],
        "generationConfig": {
            "temperature": 0.2,
            "topP": 0.95,
            "maxOutputTokens": 256,
        },
    }
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(url, data=data, headers={"Content-Type": "application/json"})
    try:
        with urllib.request.urlopen(req, timeout=30) as response:
            result = json.load(response)
    except urllib.error.HTTPError as exc:
        body = ""
        try:
            body = exc.read().decode("utf-8", errors="replace").strip()
        except OSError:
            body = ""
        message = f"HTTP {exc.code} {exc.reason}"
        if body:
            try:
                body_json = json.loads(body)
                api_message = body_json.get("error", {}).get("message")
                if api_message:
                    message += f": {api_message}"
                else:
                    message += f": {body}"
            except json.JSONDecodeError:
                message += f": {body}"
        if exc.code == 404:
            message += " (model not found; check KAMKANAM_GEMINI_MODEL)"
        raise RuntimeError(f"Gemini request failed ({model}): {message}") from exc
    try:
        return result["candidates"][0]["content"]["parts"][0]["text"]
    except (KeyError, IndexError, TypeError) as exc:
        raise RuntimeError("unexpected Gemini response") from exc


def normalize_message(text):
    if not text:
        return ""
    text = text.strip()
    if text.startswith("```"):
        lines = text.splitlines()
        if len(lines) >= 2 and lines[-1].startswith("```"):
            text = "\n".join(lines[1:-1]).strip()
    if text.startswith('"') and text.endswith('"'):
        text = text[1:-1].strip()
    return text


def first_non_empty_line(text):
    for line in text.splitlines():
        if line.strip():
            return line.strip()
    return ""


def clamp_percent(value):
    try:
        percent = int(value)
    except (TypeError, ValueError):
        return 0
    return max(0, min(100, percent))


def parse_analysis_line(text):
    text = normalize_message(text)
    line = first_non_empty_line(text)
    if not line:
        return None
    parts = line.split(" : ", 2)
    if len(parts) != 3:
        return None
    commit_type = parts[0].strip().lower()
    if commit_type in TYPE_ALIASES:
        commit_type = TYPE_ALIASES[commit_type]
    commit_message = parts[1].strip()
    ai_part = parts[2].strip()
    match = re.search(r"ai[-_ ]?usage\s+(\d{1,3})%?", ai_part, re.IGNORECASE)
    if not match:
        return None
    ai_percent = clamp_percent(match.group(1))
    if commit_type not in ALLOWED_TYPES:
        commit_type = "chore"
    return commit_type, commit_message, ai_percent


def extract_existing_subject(existing_message):
    existing_message = normalize_message(existing_message or "")
    line = first_non_empty_line(existing_message)
    if not line:
        return ""
    parsed = parse_analysis_line(line)
    if parsed:
        return parsed[1]
    return line


def strip_type_prefix(commit_message, commit_type):
    if not commit_message:
        return commit_message
    lowered = commit_message.lower()
    prefixes = [f"{commit_type}:", f"{commit_type} "]
    for prefix in prefixes:
        if lowered.startswith(prefix):
            return commit_message[len(prefix):].strip()
    return commit_message


def build_final_message(base_message, ai_percent, threshold, fallback_subject, force_ai_percent=None):
    parsed = parse_analysis_line(base_message)
    if parsed:
        commit_type, commit_message, parsed_percent = parsed
        ai_percent = parsed_percent
    else:
        commit_type = "chore"
        commit_message = fallback_subject or "update changes"
    if force_ai_percent is not None:
        ai_percent = force_ai_percent
    ai_percent = clamp_percent(ai_percent)
    commit_message = commit_message.strip()
    if not commit_message:
        commit_message = "update changes"
    commit_message = strip_type_prefix(commit_message, commit_type)
    if ai_percent > threshold and not commit_message.lower().startswith("review:"):
        commit_message = f"REVIEW: {commit_message}"
    max_message_len = int(os.getenv("KAMKANAM_MAX_MESSAGE_LEN", "72"))
    commit_message = shorten_subject(commit_message, max_len=max_message_len)
    if commit_type not in ALLOWED_TYPES:
        commit_type = "chore"
    message = f"{commit_type} : {commit_message} : ai-usage {ai_percent}"
    return message.strip() + "\n"


def strip_comments(commit_text):
    lines = []
    for line in commit_text.splitlines():
        if line.lstrip().startswith("#"):
            continue
        lines.append(line)
    return "\n".join(lines).strip()


def generate_commit_message(cwd, ai_percent, ai_percent_override, require_gemini, existing_message):
    diff_text = get_staged_diff(cwd)
    name_status = get_name_status(cwd)
    if not diff_text.strip():
        debug_log("no staged diff; using fallback message")
        fallback = extract_existing_subject(existing_message)
        return fallback if fallback else fallback_message(name_status)
    stat_text = get_stat(cwd)
    prompt = build_prompt(
        diff_text,
        stat_text,
        name_status,
        ai_percent,
        existing_message,
        ai_percent_override,
    )
    try:
        debug_log("requesting Gemini analysis")
        message = call_gemini(prompt)
        message = normalize_message(message)
    except (RuntimeError, urllib.error.URLError) as exc:
        if require_gemini:
            raise RuntimeError(f"Gemini failed: {exc}") from exc
        print(f"kamkanam: Gemini failed, using fallback: {exc}", file=sys.stderr)
        fallback = extract_existing_subject(existing_message)
        message = fallback if fallback else fallback_message(name_status)
    if message:
        debug_log("analysis line generated")
    if not message:
        fallback = extract_existing_subject(existing_message)
        message = fallback if fallback else fallback_message(name_status)
    return message


def parse_args(argv):
    parser = argparse.ArgumentParser(prog="kamkanam")
    subparsers = parser.add_subparsers(dest="command", required=True)

    generate = subparsers.add_parser("generate", help="print a commit message to stdout")
    generate.add_argument("--ai-percent", type=int, help="override AI percent (0-100)")

    hook = subparsers.add_parser("hook", help="commit-msg hook entry")
    hook.add_argument("message_file", help="path to commit message file")
    hook.add_argument("--ai-percent", type=int, help="override AI percent (0-100)")

    editor = subparsers.add_parser("editor", help="git core.editor entry")
    editor.add_argument("message_file", help="path to commit message file")
    editor.add_argument("--ai-percent", type=int, help="override AI percent (0-100)")

    return parser.parse_args(argv)


def main(argv):
    args = parse_args(argv)
    cwd = repo_root()
    diff_text = get_staged_diff(cwd)
    name_status = get_name_status(cwd)
    ai_percent_override = args.ai_percent
    env_override = os.getenv("KAMKANAM_AI_PERCENT")
    if ai_percent_override is None and env_override:
        try:
            ai_percent_override = int(env_override)
        except ValueError:
            ai_percent_override = None
    if ai_percent_override is not None:
        ai_percent = max(0, min(100, ai_percent_override))
    else:
        ai_percent = compute_ai_percent(diff_text)

    threshold = int(
        os.getenv("KAMKANAM_REVIEW_THRESHOLD")
        or os.getenv("KAMKANAM_CRUCIAL_THRESHOLD")
        or "50"
    )
    require_gemini = parse_bool(os.getenv("KAMKANAM_REQUIRE_GEMINI", "0"))
    if ai_percent_override is not None:
        debug_log(f"ai percent override: {ai_percent}% (threshold {threshold}%)")
    else:
        debug_log(f"ai percent heuristic: {ai_percent}% (threshold {threshold}%)")

    if args.command == "generate":
        existing_message = ""
        fallback_subject = fallback_message(name_status)
        base_message = generate_commit_message(
            cwd,
            ai_percent,
            ai_percent_override,
            require_gemini,
            existing_message,
        )
        final_message = build_final_message(
            base_message,
            ai_percent,
            threshold,
            fallback_subject,
            force_ai_percent=ai_percent_override,
        )
        if debug_enabled():
            debug_log("final commit message:")
            print(final_message, file=sys.stderr)
        print(final_message, end="")
        return 0

    if args.command == "hook":
        message_path = args.message_file
        try:
            with open(message_path, "r", encoding="utf-8") as handle:
                existing = handle.read()
        except OSError as exc:
            print(f"kamkanam: failed to read commit message: {exc}", file=sys.stderr)
            return 1
        existing_message = strip_comments(existing)
        fallback_subject = extract_existing_subject(existing_message)
        if not fallback_subject:
            fallback_subject = fallback_message(name_status)
        base_message = generate_commit_message(
            cwd,
            ai_percent,
            ai_percent_override,
            require_gemini,
            existing_message,
        )
        final_message = build_final_message(
            base_message,
            ai_percent,
            threshold,
            fallback_subject,
            force_ai_percent=ai_percent_override,
        )
        if debug_enabled():
            debug_log("final commit message written to hook:")
            print(final_message, file=sys.stderr)
        try:
            with open(message_path, "w", encoding="utf-8") as handle:
                handle.write(final_message)
        except OSError as exc:
            print(f"kamkanam: failed to write commit message: {exc}", file=sys.stderr)
            return 1
        return 0

    if args.command == "editor":
        message_path = args.message_file
        try:
            with open(message_path, "r", encoding="utf-8") as handle:
                existing = handle.read()
        except OSError as exc:
            print(f"kamkanam: failed to read commit message: {exc}", file=sys.stderr)
            return 1
        existing_message = strip_comments(existing)
        fallback_subject = extract_existing_subject(existing_message)
        if not fallback_subject:
            fallback_subject = fallback_message(name_status)
        base_message = generate_commit_message(
            cwd,
            ai_percent,
            ai_percent_override,
            require_gemini,
            existing_message,
        )
        final_message = build_final_message(
            base_message,
            ai_percent,
            threshold,
            fallback_subject,
            force_ai_percent=ai_percent_override,
        )
        if debug_enabled():
            debug_log("final commit message for editor:")
            print(final_message, file=sys.stderr)
        if not prompt_tui(final_message):
            print("kamkanam: commit aborted by user", file=sys.stderr)
            return 1
        try:
            with open(message_path, "w", encoding="utf-8") as handle:
                handle.write(final_message)
        except OSError as exc:
            print(f"kamkanam: failed to write commit message: {exc}", file=sys.stderr)
            return 1
        return 0

    return 1


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
