#!/usr/bin/env python3
import argparse
import json
import os
import re
import subprocess
import sys
import textwrap
import urllib.error
import urllib.request


AI_LINE_PATTERNS = [
    r"@generated",
    r"auto-?generated",
    r"generated by",
    r"do not edit",
    r"ai[- ]?generated",
    r"generated with",
    r"copilot",
    r"chatgpt",
    r"codex",
    r"gemini",
    r"codegen",
]

AI_FILE_PATTERNS = [
    r"/generated/",
    r"/codegen/",
    r"/autogen/",
    r"\.generated\.",
    r"\.gen\.",
    r"_generated\.",
    r"_gen\.",
]


def run_git(args, cwd):
    result = subprocess.run(
        ["git"] + args,
        cwd=cwd,
        text=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        check=False,
    )
    if result.returncode != 0:
        raise RuntimeError(result.stderr.strip() or "git command failed")
    return result.stdout


def parse_bool(value):
    return str(value).lower() in ("1", "true", "yes", "on")


def debug_enabled():
    return parse_bool(os.getenv("KAMKANAM_DEBUG", "0"))


def debug_log(message):
    if debug_enabled():
        print(f"kamkanam: {message}", file=sys.stderr)


def gemini_model():
    return os.getenv("KAMKANAM_GEMINI_MODEL", "gemini-2.5-flash")


def tui_enabled():
    return parse_bool(os.getenv("KAMKANAM_TUI", "1"))


def prompt_tui(message):
    if not tui_enabled():
        debug_log("tui disabled; auto-accepting")
        return True
    try:
        tty = open("/dev/tty", "r+")
    except OSError:
        debug_log("no tty available; auto-accepting")
        return True
    with tty:
        tty.write("\nkamkanam commit message:\n")
        tty.write("-" * 72 + "\n")
        tty.write(message.rstrip() + "\n")
        tty.write("-" * 72 + "\n")
        tty.write("Press Enter to accept, or type 'q' to abort: ")
        tty.flush()
        response = tty.readline()
    if response is None:
        return True
    response = response.strip().lower()
    return response not in ("q", "quit", "n", "no")


def repo_root():
    try:
        root = run_git(["rev-parse", "--show-toplevel"], cwd=os.getcwd()).strip()
    except RuntimeError as exc:
        raise RuntimeError("not a git repository") from exc
    if not root:
        raise RuntimeError("not a git repository")
    return root


def get_staged_diff(cwd):
    return run_git(["diff", "--cached", "--unified=0", "--no-color"], cwd=cwd)


def get_stat(cwd):
    return run_git(["diff", "--cached", "--stat", "--no-color"], cwd=cwd)


def get_name_status(cwd):
    output = run_git(["diff", "--cached", "--name-status", "-z"], cwd=cwd)
    parts = output.split("\0")
    items = []
    i = 0
    while i < len(parts):
        entry = parts[i]
        if not entry:
            i += 1
            continue
        if "\t" in entry:
            status, path = entry.split("\t", 1)
        else:
            status, path = entry, ""
        code = status[:1]
        if code in ("R", "C"):
            old_path = path
            new_path = ""
            if i + 1 < len(parts):
                new_path = parts[i + 1]
                i += 1
            items.append((code, old_path, new_path))
        else:
            items.append((code, path, None))
        i += 1
    return items


def compile_patterns(patterns):
    return [re.compile(p, re.IGNORECASE) for p in patterns]


AI_LINE_REGEX = compile_patterns(AI_LINE_PATTERNS)
AI_FILE_REGEX = compile_patterns(AI_FILE_PATTERNS)


def is_ai_line(line):
    return any(regex.search(line) for regex in AI_LINE_REGEX)


def is_ai_file(path):
    return any(regex.search(path) for regex in AI_FILE_REGEX)


def compute_ai_percent(diff_text):
    total_added = 0
    ai_added = 0
    current_ai_file = False
    for line in diff_text.splitlines():
        if line.startswith("+++ "):
            path = line[4:].strip()
            if path.startswith("b/"):
                path = path[2:]
            current_ai_file = is_ai_file(path)
            continue
        if line.startswith("+") and not line.startswith("+++"):
            total_added += 1
            content = line[1:]
            if current_ai_file or is_ai_line(content):
                ai_added += 1
    if total_added == 0:
        return 0
    return int(round(100 * ai_added / total_added))


def fallback_message(name_status):
    if not name_status:
        return "chore: empty commit"
    if len(name_status) == 1:
        code, path, new_path = name_status[0]
        if code == "A":
            subject = f"add {path}"
        elif code == "D":
            subject = f"remove {path}"
        elif code == "R" and new_path:
            subject = f"rename {path} to {new_path}"
        elif code == "C" and new_path:
            subject = f"copy {path} to {new_path}"
        else:
            subject = f"update {path}"
        return shorten_subject(subject)
    return f"update {len(name_status)} files"


def shorten_subject(subject, max_len=72):
    subject = subject.strip()
    if len(subject) <= max_len:
        return subject
    return subject[: max_len - 3].rstrip() + "..."


def build_prompt(diff_text, stat_text, name_status, ai_percent):
    max_chars = int(os.getenv("KAMKANAM_MAX_DIFF_CHARS", "12000"))
    diff_excerpt = diff_text[:max_chars]
    if len(diff_text) > max_chars:
        diff_excerpt += "\n...[diff truncated]"
    files_list = []
    for code, path, new_path in name_status:
        if code == "R" and new_path:
            files_list.append(f"R {path} -> {new_path}")
        elif code == "C" and new_path:
            files_list.append(f"C {path} -> {new_path}")
        else:
            files_list.append(f"{code} {path}")
    files_block = "\n".join(files_list) if files_list else "(none)"
    prompt = textwrap.dedent(
        f"""\
        You generate precise git commit messages from staged diffs.

        Requirements:
        - Output only the commit message (no markdown fences, no quotes).
        - Use an imperative, <=72 character subject line.
        - Add a short body only when it adds value.
        - Do not include any AI metadata or CRUCIAL prefix.

        Diff stat:
        {stat_text.strip() or "(empty)"}

        AI usage heuristic (added lines flagged): {ai_percent}%

        Changed files:
        {files_block}

        Staged diff (truncated if needed):
        {diff_excerpt.strip() or "(empty)"}
        """
    )
    return prompt


def call_gemini(prompt):
    api_key = os.getenv("KAMKANAM_GEMINI_API_KEY") or os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise RuntimeError("missing Gemini API key")
    model = gemini_model()
    debug_log(f"using Gemini model: {model}")
    url = (
        "https://generativelanguage.googleapis.com/v1beta/models/"
        f"{model}:generateContent?key={api_key}"
    )
    payload = {
        "contents": [{"role": "user", "parts": [{"text": prompt}]}],
        "generationConfig": {
            "temperature": 0.2,
            "topP": 0.95,
            "maxOutputTokens": 256,
        },
    }
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(url, data=data, headers={"Content-Type": "application/json"})
    try:
        with urllib.request.urlopen(req, timeout=30) as response:
            result = json.load(response)
    except urllib.error.HTTPError as exc:
        body = ""
        try:
            body = exc.read().decode("utf-8", errors="replace").strip()
        except OSError:
            body = ""
        message = f"HTTP {exc.code} {exc.reason}"
        if body:
            try:
                body_json = json.loads(body)
                api_message = body_json.get("error", {}).get("message")
                if api_message:
                    message += f": {api_message}"
                else:
                    message += f": {body}"
            except json.JSONDecodeError:
                message += f": {body}"
        if exc.code == 404:
            message += " (model not found; check KAMKANAM_GEMINI_MODEL)"
        raise RuntimeError(f"Gemini request failed ({model}): {message}") from exc
    try:
        return result["candidates"][0]["content"]["parts"][0]["text"]
    except (KeyError, IndexError, TypeError) as exc:
        raise RuntimeError("unexpected Gemini response") from exc


def normalize_message(text):
    if not text:
        return ""
    text = text.strip()
    if text.startswith("```"):
        lines = text.splitlines()
        if len(lines) >= 2 and lines[-1].startswith("```"):
            text = "\n".join(lines[1:-1]).strip()
    if text.startswith('"') and text.endswith('"'):
        text = text[1:-1].strip()
    return text


def build_final_message(base_message, ai_percent, threshold):
    raw_lines = [line.rstrip() for line in base_message.splitlines()]
    while raw_lines and not raw_lines[0].strip():
        raw_lines.pop(0)
    while raw_lines and not raw_lines[-1].strip():
        raw_lines.pop()
    if not raw_lines:
        raw_lines = ["chore: update changes"]
    subject = raw_lines[0].strip()
    if ai_percent > threshold and not subject.startswith("CRUCIAL:"):
        subject = f"CRUCIAL: {subject}"
    subject = shorten_subject(subject)
    body_lines = raw_lines[1:]
    body_lines = [line for line in body_lines if not line.lower().startswith("ai-percent:")]
    while body_lines and not body_lines[0].strip():
        body_lines.pop(0)
    if body_lines:
        body_lines.insert(0, "")
    footer = f"AI-Percent: {ai_percent}%"
    message_lines = [subject] + body_lines + ["", footer]
    return "\n".join(message_lines) + "\n"


def strip_comments(commit_text):
    lines = []
    for line in commit_text.splitlines():
        if line.lstrip().startswith("#"):
            continue
        lines.append(line)
    return "\n".join(lines).strip()


def generate_commit_message(cwd, ai_percent, require_gemini):
    diff_text = get_staged_diff(cwd)
    name_status = get_name_status(cwd)
    if not diff_text.strip():
        debug_log("no staged diff; using fallback message")
        return fallback_message(name_status)
    stat_text = get_stat(cwd)
    prompt = build_prompt(diff_text, stat_text, name_status, ai_percent)
    try:
        debug_log("requesting Gemini commit message")
        message = call_gemini(prompt)
        message = normalize_message(message)
    except (RuntimeError, urllib.error.URLError) as exc:
        if require_gemini:
            raise RuntimeError(f"Gemini failed: {exc}") from exc
        print(f"kamkanam: Gemini failed, using fallback: {exc}", file=sys.stderr)
        message = fallback_message(name_status)
    if message:
        debug_log("commit message generated")
    if not message:
        message = fallback_message(name_status)
    return message


def parse_args(argv):
    parser = argparse.ArgumentParser(prog="kamkanam")
    subparsers = parser.add_subparsers(dest="command", required=True)

    generate = subparsers.add_parser("generate", help="print a commit message to stdout")
    generate.add_argument("--ai-percent", type=int, help="override AI percent (0-100)")

    hook = subparsers.add_parser("hook", help="commit-msg hook entry")
    hook.add_argument("message_file", help="path to commit message file")
    hook.add_argument("--ai-percent", type=int, help="override AI percent (0-100)")

    editor = subparsers.add_parser("editor", help="git core.editor entry")
    editor.add_argument("message_file", help="path to commit message file")
    editor.add_argument("--ai-percent", type=int, help="override AI percent (0-100)")

    return parser.parse_args(argv)


def main(argv):
    args = parse_args(argv)
    cwd = repo_root()
    diff_text = get_staged_diff(cwd)
    ai_percent_override = args.ai_percent
    env_override = os.getenv("KAMKANAM_AI_PERCENT")
    if ai_percent_override is None and env_override:
        try:
            ai_percent_override = int(env_override)
        except ValueError:
            ai_percent_override = None
    if ai_percent_override is not None:
        ai_percent = max(0, min(100, ai_percent_override))
    else:
        ai_percent = compute_ai_percent(diff_text)

    threshold = int(os.getenv("KAMKANAM_CRUCIAL_THRESHOLD", "50"))
    require_gemini = parse_bool(os.getenv("KAMKANAM_REQUIRE_GEMINI", "0"))
    debug_log(f"ai percent: {ai_percent}% (threshold {threshold}%)")

    if args.command == "generate":
        base_message = generate_commit_message(cwd, ai_percent, require_gemini)
        final_message = build_final_message(base_message, ai_percent, threshold)
        if debug_enabled():
            debug_log("final commit message:")
            print(final_message, file=sys.stderr)
        print(final_message, end="")
        return 0

    if args.command == "hook":
        message_path = args.message_file
        try:
            with open(message_path, "r", encoding="utf-8") as handle:
                existing = handle.read()
        except OSError as exc:
            print(f"kamkanam: failed to read commit message: {exc}", file=sys.stderr)
            return 1
        base_message = strip_comments(existing)
        if not base_message:
            base_message = generate_commit_message(cwd, ai_percent, require_gemini)
        final_message = build_final_message(base_message, ai_percent, threshold)
        if debug_enabled():
            debug_log("final commit message written to hook:")
            print(final_message, file=sys.stderr)
        try:
            with open(message_path, "w", encoding="utf-8") as handle:
                handle.write(final_message)
        except OSError as exc:
            print(f"kamkanam: failed to write commit message: {exc}", file=sys.stderr)
            return 1
        return 0

    if args.command == "editor":
        message_path = args.message_file
        try:
            with open(message_path, "r", encoding="utf-8") as handle:
                existing = handle.read()
        except OSError as exc:
            print(f"kamkanam: failed to read commit message: {exc}", file=sys.stderr)
            return 1
        base_message = strip_comments(existing)
        if not base_message:
            base_message = generate_commit_message(cwd, ai_percent, require_gemini)
        final_message = build_final_message(base_message, ai_percent, threshold)
        if debug_enabled():
            debug_log("final commit message for editor:")
            print(final_message, file=sys.stderr)
        if not prompt_tui(final_message):
            print("kamkanam: commit aborted by user", file=sys.stderr)
            return 1
        try:
            with open(message_path, "w", encoding="utf-8") as handle:
                handle.write(final_message)
        except OSError as exc:
            print(f"kamkanam: failed to write commit message: {exc}", file=sys.stderr)
            return 1
        return 0

    return 1


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
